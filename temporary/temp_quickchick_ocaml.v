(** File generated by coq-of-ocaml *)
Require Import CoqOfOCaml.CoqOfOCaml.
Require Import CoqOfOCaml.Settings.

Inductive tree : Set :=
| E : tree
| T : tree -> nat -> nat -> tree -> tree.

Definition fuel : nat := 10000.

Fixpoint insert (k_value : int) (v_value : int) (t_value : tree) : tree :=
  match t_value with
  | E => T E k_value v_value E
  | T l_value k' v' r_value =>
    let '_ := CoqOfOCaml.Stdlib.ignore (l_value, k', v', r_value, insert) in
    T E k_value v_value E
  end.

Fixpoint join (l_value : tree) (r_value : tree) : tree :=
  match (l_value, r_value) with
  | (E, _) => r_value
  | (_, E) => l_value
  | (T l_value k_value v_value r_value, T l' k' v' r') =>
    T l_value k_value v_value (T (join r_value l') k' v' r')
  end.

Fixpoint delete (k_value : int) (t_value : tree) : tree :=
  match t_value with
  | E => E
  | T l_value k' v' r_value =>
    if CoqOfOCaml.Stdlib.lt k_value k' then
      T (delete k_value l_value) k' v' r_value
    else
      if CoqOfOCaml.Stdlib.lt k' k_value then
        T l_value k' v' (delete k_value r_value)
      else
        join l_value r_value
  end.

Fixpoint below (k_value : int) (t_value : tree) : tree :=
  match (k_value, t_value) with
  | (_, E) => E
  | (k_value, T l_value k' v_value r_value) =>
    if CoqOfOCaml.Stdlib.le k_value k' then
      below k_value l_value
    else
      T l_value k' v_value (below k_value r_value)
  end.

Fixpoint above (k_value : int) (t_value : tree) : tree :=
  match (k_value, t_value) with
  | (_, E) => E
  | (k_value, T l_value k' v_value r_value) =>
    if CoqOfOCaml.Stdlib.le k' k_value then
      above k_value r_value
    else
      T (above k_value l_value) k' v_value r_value
  end.

Fixpoint union_ (l_value : tree) (r_value : tree) (f_value : int) : tree :=
  match f_value with
  | 0 => E
  | _ =>
    let f' := Z.sub f_value 1 in
    match (l_value, r_value) with
    | (E, _) => r_value
    | (_, E) => l_value
    | (T l_value k_value v_value r_value, t_value) =>
      T (union_ l_value (below k_value t_value) f') k_value v_value
        (union_ r_value (above k_value t_value) f')
    end
  end.

Definition union (l_value : tree) (r_value : tree) : tree :=
  union_ l_value r_value fuel.

Fixpoint find (k_value : int) (t_value : tree) : option nat :=
  match (k_value, t_value) with
  | (_, E) => None
  | (k_value, T l_value k' v' r_value) =>
    if CoqOfOCaml.Stdlib.lt k_value k' then
      find k_value l_value
    else
      if CoqOfOCaml.Stdlib.lt k' k_value then
        find k_value r_value
      else
        Some v'
  end.

Fixpoint size (t_value : tree) : nat :=
  match t_value with
  | E => 0
  | T l_value _ _ r_value => Z.add (Z.add 1 (size l_value)) (size r_value)
  end.

Definition prop_InsertPost : tree -> nat -> nat -> nat -> bool :=
  let fix keys (t_value : tree) : list nat :=
    match t_value with
    | E => nil
    | T l_value k_value _v r_value =>
      let lk := keys l_value in
      let rk := keys r_value in
      CoqOfOCaml.Stdlib.app [ k_value ] (CoqOfOCaml.Stdlib.app lk rk)
    end in
  let fix all (f_value : nat -> bool) (l_value : list int) : bool :=
    match l_value with
    | [] => true
    | cons x_value xs => andb (f_value x_value) (all f_value xs)
    end in
  let fix isBST (t_value : tree) : bool :=
    match t_value with
    | E => true
    | T l_value k_value _ r_value =>
      andb (isBST l_value)
        (andb (isBST r_value)
          (andb
            (all (fun (k' : int) => CoqOfOCaml.Stdlib.lt k' k_value)
              (keys l_value))
            (all (fun (k' : int) => CoqOfOCaml.Stdlib.gt k' k_value)
              (keys r_value))))
    end in
  fun (t_value : tree) =>
    fun (k_value : int) =>
      fun (k' : int) =>
        fun (v_value : int) =>
          orb (negb (isBST t_value))
            (equiv_decb (find k' (insert k_value v_value t_value))
              (if equiv_decb k_value k' then
                Some v_value
              else
                find k' t_value)).
